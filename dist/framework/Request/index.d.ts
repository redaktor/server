/// <reference types="node" />
import { authRequest, authResponse } from './interfaces';
declare type FN = (data: any) => void;
declare class RequestMixin {
    protected messages: {};
    protected key?: string;
    protected secret?: string;
    debug: boolean;
    protected _authHeaderKey: string;
    protected _protocol: string;
    protected _version: string;
    protected _type: string;
    protected _headerPrefix: string;
    protected _nonceSize: number;
    _options: any;
    protected authOptions: any;
    get protocolStr(): string;
    constructor(messages?: {}, key?: string, secret?: string);
    initRequest(): void;
    protected proxy(res: authResponse<any>, data: any, type?: string): any;
    protected responseTypes: any;
    protected registerType(type: string): (res: authResponse<any>) => boolean;
    protected _getUUID(str?: string): string;
    protected _getNonce(lengthOrMin?: number, maxLength?: number): string;
    protected _escapeHTML(str: string): string;
    protected _getTimestamp(): string;
    protected _fixEncode(str: string): string;
    protected _encode(toEncode: string | Buffer): string;
    protected _decode(toDecode: string): string;
    protected _urlEncode(str: string): string;
    protected _urlDecode(str: string): string;
    msg(_id?: any, el?: any, bundle?: any, fallback?: string, doReturn?: boolean): string;
    errLog(_text: string, _status?: number, _data?: any): string;
    debugLog(logArr: any, doPadding?: boolean, inclFn?: boolean): void;
    initDebugLog(secretKeys?: string[], excludeKeys?: string[]): void;
    requestLog(opts: authRequest | any): any;
    error(id?: string, statusCode?: number, isPromise?: boolean): any;
    debugError(res: any): {
        prefix: string;
        msg: string;
    };
    protected _resolveRelative(mainUrl: string, url: string): any;
    protected _normalizeUrl(url: any, inclQuery?: boolean, nonHTTPto?: string): string;
    protected _getRequest(url: string, myOptions: any): any;
    private _getClientOptions;
    getClientOptions(kwArgs?: any): any;
    protected getAuthHeader(...a: any[]): string;
    reply(res: authResponse<{}>, kwArgs: any, myOptions: any, success?: FN, err?: FN): void | authResponse<{}>;
    request(kwArgs: authRequest | any, success?: FN, reqError?: FN): any;
    _kwArgs(urlOrKwArgs: authRequest | string, kwArgs?: authRequest): authRequest;
    urlToObj(obj: any, name: string): authRequest;
    options(o?: any, ...optionObjects: any[]): Promise<any>;
    head(urlOrKwArgs: authRequest | string, kwArgs?: authRequest): any;
    get(urlOrKwArgs: authRequest | string, kwArgs?: authRequest): any;
    put(urlOrKwArgs: authRequest | string, kwArgs?: authRequest): any;
    post(urlOrKwArgs: authRequest | string, kwArgs?: authRequest): any;
    delete(urlOrKwArgs: authRequest | string, kwArgs?: authRequest): any;
    isObject(v: any): boolean;
    isPutPost(kwArgs: any): boolean;
    hasRedirect(res: any): boolean;
    copy(o?: any, getPointer?: string, setPointer?: string, mix?: boolean): any;
    mix(o?: any, getPointer?: string, setPointer?: string): any;
    forceHTTPS(o?: any): any;
    redirectPage(): string;
    redirect(o: any, params?: any, rUrl?: string): {
        url: any;
    };
}
export default RequestMixin;
